- 微前端是一种类似于微服务的架构，是一种由独立交付的多个前端应用组成整体的架构风格，将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用，而在用户看来仍然是内聚的单个产品。

### 微前端解决的问题（背景）
1. 随着项目迭代应用越来越庞大，难以维护。
2. 项目比较陈旧，业务迁移到新项目，提高开发效率、代码可维护性、性能优化等。（新业务用新的技术栈来开发，之后利用微前端接入到老项目）
3. 跨团队或跨部门协作开发项目导致效率低下的问题。

### 如何实现微前端（怎样实现）
- 我们可以将一个应用划分成若干个子应用，将子应用打包成一个个的模块。当路径切换时加载不同的子应用。这样每个子应用都是独立的，技术栈也不用做限制了。

### 实现微前端技术方案（方案选择。实现的方案）
- 采用何种方案进行应用拆分？（拆分了之后还要接入到基座）
- 采用何种方式进行应用通信？
- 应用之间如何进行隔离？
  #### 具体方案
    1. iframe
      - 微前端的最简单方案，通过 iframe 加载子应用
      - 通信可以通过 postMessage 进行通信
      - 完美的沙箱机制自带应用隔离
      - 缺点：用户体验差（弹窗只能在 iframe 中、在内部切换刷新就会丢失状态）
    2. Web Components
      - 将前端应用程序分解为自定义 HTML 元素
      - 基于 CustomEvent 实现通信
      - Shadow DOM 天生的作用域隔离
      - 缺点：浏览器支持问题、学习成本、调式困难、修改样式困难等问题
    3. single-spa
      - single-spa 通过路由劫持实现应用的加载（采用 Systemjs），提供应用间公共组件加载及公共业务逻辑处理。子应用需要暴露固定的钩子（bootstrap、mount、unmount）
      - 基于 props 主子应用间通信
      - 无沙箱机制，需要自己实现 js 沙箱以及 css 沙箱
      - 缺点：学习成本、无沙箱机制、需要对原有的应用进行改造、子应用间相同资源重复加载问题
    4. Module federation（模块联邦）
      - 通过模块联邦将组件进行打包导出使用
      - 共享模块的方式进行通过
      - 无 css 沙箱和 js 沙箱
      - 缺点：需要 webpack5

### 微前端
- 微前端的核心概念：生命周期（初始化、挂载、卸载）
- 基座只需要关心子应用的：
  - 初始化，bootstrap
  - 挂载，mount
  - 卸载，unmount

### 微前端原理剖析
- 生命周期（子应用接入协议）
- 样式隔离
  - 工程化手段
  - 动态样式表
  - Shadow DOM
  - runtime css transformer
- 应用隔离
  - 快照沙箱
  - 代理沙箱
- 通信
  - url 机制
  - 事件机制
  - props