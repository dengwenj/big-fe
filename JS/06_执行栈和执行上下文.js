/**
 * 执行上下文，Execution Context，一句话概括就是”代码（全局代码、函数代码）执行前进行的准备工作“，也称之为”执行上下文环境“
 * 当代码执行进入一个环境时，就会为该环境创建一个执行上下文，它会在运行代码前做一些准备工作，如确定作用域，创建局部变量对象等等
 * 
 * js 中执行环境
 * 1、全局环境
 * 2、函数环境
 * 3、eval 函数环境
 * 那么与之对应的执行上下文类型同样有 3 种：
 * 1、全局执行上下文
 * 2、函数执行上下文
 * 3、eval 函数执行上下文
 */
var a = 1
console.log(a)
// 在执行上面的全局代码之前，还有一个准备工作，就是创建一个全局上下文

console.log("你好")
function foo() {
  function bar() {
    return "foo bar"
  }
  return bar()
}
foo()
console.log("世界")
/**
 * 函数调用栈：
 * 程序执行进入一个执行环境时，它的执行上下文就会被创建，并被推入执行栈中（入栈），程序执行完成时，它的执行上下文就会被销毁，并从栈顶被推出（出栈），控制权交给下一个执行上下文
 * 处于栈低的永远是全局环境的执行上下文，而处于栈顶的是当前正在执行函数的执行上下文
 * 当函数调用完成后，它就会从栈顶被推出
 * 全局环境只有一个，对应的全局执行上下文也只有一个，只有当页面被关闭之后才会从执行栈中被推出，否则一直存在于栈低
 */

/**
 * 执行上下文的生命周期有两个阶段：
 * 1、创建阶段（进入执行上下文）：函数被调用时，进入函数环境，为其创建一个执行上下文，此时进入创建阶段
 * 2、执行阶段（代码执行）：执行函数中的代码时，此时执行上下文进入执行阶段
 * 
 * 创建阶段：
 * 1、创建变量对象（VO：variable object）
 * - 确定函数的形参（并赋值）
 * - 函数环境会初始化创建 Arguments 对象（并赋值）
 * - 确定普通字面量形式的函数声明（并赋值）
 * - 变量声明，函数表达式声明（未赋值）
 * 在进行变量声明的时候，如果发现该变量名已经存在，则不会再声明
 * 2、确定 this 指向（this 由调用者确定）
 * 3、确定作用域（词法环境决定、哪里声明定义、就在哪里确定）
 */
;(function () {
  console.log(typeof foo); // function
  console.log(typeof bar); // undefined
  var foo = "hello"
  var bar = function() {
    return "World"
  }
  
  function foo() {
    return "good"
  }
  console.log(foo, typeof foo); // hello, string
})()

// executionContext = {
//   vo: {
//     // foo: 函数,
//     foo: 'hello',
//     bar: undefined
//   },
//   // this,
//   // scope chain: vo + parentScope
// }