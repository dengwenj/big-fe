/**
 * 1、解析 HTML：生成 DOM 树和 CSSOM 树
 * 如果主线程解析到 script 位置，会停止解析 HTML，转而等待 js 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML
 * 这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因
 * 如果想要首屏渲染的越快，就越不应该在最前面就加载 js 文件，这也是都建议将 script 标签放在 body 标签结束之前的原因。
 * 另外，在现代浏览器中，为我们提供了新的方式来避免 JS 代码阻塞渲染的情况：
 * async、defer、prefetch、preload
 * 
 * 2、样式计算：把 CSSOM 树样式匹配到 DOM  树上。两棵树合并成一棵树，带样式的 DOM 树
 * 
 * 3、布局：
 * 带样式的 DOM 树是远远不足以渲染出页面内容的，还需要通过布局（layout）来计算出每个节点的几何信息。
 * 生成布局树的具体过程是：主线程会遍历刚刚构建的 DOM，根据 DOM 节点的计算样式计算出一个布局树，布局树上每个节点会有它在页面上的坐标以及盒子大小的具体信息
 * 布局树大部分时候和 DOM 树并非一一对应。虽然它长得和先前构建的 DOM 树差不多，但是不同的是这棵树只有那些可见的节点信息
 * 比如：display: none 的节点没有几何信息，因此不会生产到布局树
 * 又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中
 * 
 * 4、分层
 * 分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。
 * 为了确定哪些元素需要放置在哪一层，主线程需要遍历整颗布局树来创建一颗层次树
 * 滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过使用 will-change 属性来告诉浏览器对其分层
 * 
 * 5、生成绘制指令
 * 这一步只是生成绘制指令，还没开始执行这些指令。渲染主线程的工作就暂时告一段落，接下来主线程将每个图层的绘制信息交给合成线程来完成
 * 
 * 6、分块
 * 合成线程首先对每个图层进行分块，将其划分为更多的小区域，它不再是像主线程那样一个人在战斗，它会从线程池中拿去多个线程来完成分块工作
 * 分块的工作是交给多个线程同时进行的
 * 
 * 7、光栅化
 * 分块完成后，进入光栅化阶段。所谓光栅化，就是将每个块变成位图。
 * 更简单的理解就是确定每一个像素点的 rgb 信息
 * 光栅化的操作，并不由合成线程来做，而是会由合成线程将块信息交给 GPU 进程，以极高的速度完成光栅化
 * 
 * 8、绘制
 * 当所有的图块都被栅格化后，合成线程会拿到每个层、每个块的位图，从而生成一个个指引信息
 * 合成线程计算出每个位图在屏幕上的位置，交给 GPU 进行最终呈现
 * 指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形，变形发生在合成线程，与渲染主线程无关，这就是 transform 效率高的本质原因
 * 
 * 什么是 reflow（回流、重排）？
 * reflow 的本质就是重新计算 layout 树
 * 像修改宽度、边距。
 * 为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的
 * 也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息，浏览器在反复权衡下，最终决定获取属性立即 reflow
 * 
 * 什么是 repaint？(重绘)
 * 重绘的本质就是重新根据分层信息计算绘制指令
 * 当改动了可见样式后，就需要重新计算，会引发 repaint。像修改了颜色
 * 由于元素的布局信息页属于可见样式，所以 reflow 一定会引起 repaint
 */
