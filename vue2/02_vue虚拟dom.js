/**
 * 虚拟 dom 最终是通过 render 函数来创建的，虚拟 dom 对象是通过 render 函数返回的
 * 模版 template 最终还是要转为 render 函数的
 * vue 中的 h 函数就是生成虚拟 dom 的
 * 
 * 1、什么是虚拟 DOM
 * 虚拟 dom 本质就是一个普通的 JS 对象，用于描述视图的界面结构
 * 在 vue 中，每个组件都有一个 render 函数，每个 render 函数都会返回一个虚拟 dom 树，这也就意味着每个组件都对应一颗虚拟 dom 树
 * 
 * 2、为什么需要虚拟 dom
 * 在 vue 中，渲染视图会调用 render 函数，这种渲染不仅发生在组件创建时，同时发生在视图依赖的数据更新时。
 * 如果在渲染时，直接使用真实 dom，由于真实 dom 的创建、更新、插入等操作会带来大量的性能损耗，从而就会极大的降低渲染效率。
 * 因此，vue 在渲染时，使用虚拟 dom 来替代真实 dom，主要为了解决渲染效率的问题
 * 
 * 3、虚拟 dom 是如何转换为真实 dom 的
 * 在一个组件实例首次被渲染时，它先生成虚拟 dom 树，然后根据虚拟 dom 树创建真实 dom，并把真实 dom 挂载到页面中合适的位置，
 * 此时，每个虚拟 dom 便会对应一个真实的 dom。
 * 如果一个组件受到响应式数据变化的影响，需要重新渲染时，它仍然会重新调用 render 函数，创建出一个新的虚拟 dom，直接使用新的虚拟 dom
 * 抛弃旧的虚拟 dom，用新树和旧树对比，通过对比，vue 会找到最小更新量(diff 算法)，然后更新必要的虚拟 dom 节点，
 * 最后，更新这些虚拟节点，修改它们的真实 dom，这样一来，就保证了对真实 dom 达到最小的改动
 * 
 * 4、模版和虚拟 dom 的关系
 * vue 框架中有一个 compile 模块，它主要负责将模版转换为 render 函数，而 render 函数调用后将得到虚拟 dom
 * 编译的过程分两步：
 * - 将模版字符串转换成 AST(抽象语法树)
 * - 将 AST 转换为 render 函数
 * 如果使用传统的引入方式，则编译时间发生在组件第一次加载时，这称之为运行时编译
 * 如果是在 vue-cli 的默认配置下，编译发生在打包时，这称之为模版预编译
 * 编译时一个极其消耗性能的操作，预编译可以有效的提高运行时的性能，而且，由于运行的时候已不需要编译，vue-cli 在打包时会排除掉 vue
 * 中的 compile 模块，以减少打包体积。模版的存在，仅仅是为了让开发人员更加方便的书写代码
 * vue 最终运行的时候，最终需要的是 render 函数，而不是模版，因此，模版中的各种语法，在虚拟 dom 中都是不存在的，它们都会变成虚拟 dom 的配置
 */
