### 性能优化

### 构建性能
- 这里所说的构建性能，是指在开发阶段的构建性能，而不是生产环境的构建性能
- 优化的目标，是降低从打包开始，到代码效果呈现所经过的时间
- 构建性能会影响开发效率。构建性能越高，开发过程中时间的浪费越少

### 传输性能
- 传输性能是指，打包后的 js 代码传输到浏览器经过的时间
- 在优化传输性能时要考虑到：
  1. 总传输量：所有需要传输的 js 文件的内容加起来，就是总传输量，重复代码越少，总传输量越少
  2. 文件数量：当访问页面时，需要传输的 js 文件数量，文件数量越多，http 请求越多，消耗越大，响应速度越慢
  3. 浏览器缓存：js 文件会被浏览器缓存，被缓存的文件不会再进行传输

### 运行性能
- 运行性能是指，js 代码在浏览器端的运行速度

### 构建性能优化
1. **减少模块解析**
  - 默认情况下所有的模块都会去解析（抽象语法树分析、依赖分析、模块语法替换）
  - 如果某个模块不做解析，该模块经过 loader 处理后的代码就是最终代码
  - 如果没有 loader 对该模块进行处理，该模块的源码就是最终打包结果的代码
  - 如果不对某个模块进行解析，可以缩短构建时间

  - 哪些模块不需要解析？
    - 模块中无其他依赖。比如：一些已经打包好的第三方库，比如 jquery

  - 如何让某个模块不要解析？
    - 配置 module.noParse，它是一个正则，被正则匹配到的模块不会解析
    ```js
    module: {
      // 哪些模块不需要解析
      noParse: /jquery/
    }
    ```
2. **优化 loader 性能**
  - 进一步限制 loader 的应用范围
  - 通过 module.rule.exclude 或 module.rule.include，排除或进包含需要应用 loader 的场景
  ```js
  module: {
    rules: [
      {
        test: /\.js$/,
        // 排除
        // exclude: /lodash/
        exclude: /node_modules/,
        use: 'babel-loader'
      }
    ]
  }
  ```
  - 缓存 loader 的结果
  - 为 loader 的运行开启多线程，开启和管理线程需要消耗时间，在小型项目中使用 thread-loader 反而会增加构建时间

3. HMR 热替换
 - webpack dev server 每次都要重新打包吗？
  - 开启热更新（Hot Module Replacement，HMR）
    - 当开启热更新功能时，webpack-dev-server 可以在不重新打包整个项目的情况下更新发生变化的模块。
    - 原理：webpack 会追踪模块之间的依赖关系并构建依赖图。当监测到文件变化时，它会根据依赖图确定哪些模块受影响，仅重新编译这些受影响的模块，然后将更新后的模块代码发送到浏览器（websocket）。浏览器中的 HMR 运行时会接收这些更新，并用新模块替换旧模块，而无需刷新整个页面。
  - 未开启热更新
    - 若未开启热更新，webpack-dev-server 在检测到文件变化时，会重新打包整个项目并刷新浏览器页面。
    - 原理：由于没有 HMR 机制来单独更新模块，当文件变化时，webpack 会重新从入口文件开始解析所有模块，生成新的打包文件，然后通知浏览器重新加载页面以显示最新的打包结果。