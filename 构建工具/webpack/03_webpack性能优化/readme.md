### 性能优化

### 构建性能
- 这里所说的构建性能，是指在开发阶段的构建性能，而不是生产环境的构建性能
- 优化的目标，是降低从打包开始，到代码效果呈现所经过的时间
- 构建性能会影响开发效率。构建性能越高，开发过程中时间的浪费越少

### 传输性能
- 传输性能是指，打包后的 js 代码传输到浏览器经过的时间
- 在优化传输性能时要考虑到：
  1. 总传输量：所有需要传输的 js 文件的内容加起来，就是总传输量，重复代码越少，总传输量越少
  2. 文件数量：当访问页面时，需要传输的 js 文件数量，文件数量越多，http 请求越多，消耗越大，响应速度越慢
  3. 浏览器缓存：js 文件会被浏览器缓存，被缓存的文件不会再进行传输

### 运行性能
- 运行性能是指，js 代码在浏览器端的运行速度

### 构建性能优化
1. **减少模块解析**
  - 默认情况下所有的模块都会去解析（抽象语法树分析、依赖分析、模块语法替换）
  - 如果某个模块不做解析，该模块经过 loader 处理后的代码就是最终代码
  - 如果没有 loader 对该模块进行处理，该模块的源码就是最终打包结果的代码
  - 如果不对某个模块进行解析，可以缩短构建时间

  - 哪些模块不需要解析？
    - 模块中无其他依赖。比如：一些已经打包好的第三方库，比如 jquery

  - 如何让某个模块不要解析？
    - 配置 module.noParse，它是一个正则，被正则匹配到的模块不会解析
    ```js
    module: {
      // 哪些模块不需要解析
      noParse: /jquery/
    }
    ```
2. **优化 loader 性能**
  - 进一步限制 loader 的应用范围
  - 通过 module.rule.exclude 或 module.rule.include，排除或进包含需要应用 loader 的场景
  ```js
  module: {
    rules: [
      {
        test: /\.js$/,
        // 排除
        // exclude: /lodash/
        exclude: /node_modules/,
        use: 'babel-loader'
      }
    ]
  }
  ```
  - 缓存 loader 的结果
  - 为 loader 的运行开启多线程，开启和管理线程需要消耗时间，在小型项目中使用 thread-loader 反而会增加构建时间

3. **HMR 热替换**
 - webpack dev server 每次都要重新打包吗？
  - 开启热更新（Hot Module Replacement，HMR）
    - 当开启热更新功能时，webpack-dev-server 可以在不重新打包整个项目的情况下更新发生变化的模块。
    - 原理：webpack 会追踪模块之间的依赖关系并构建依赖图。当监测到文件变化时，它会根据依赖图确定哪些模块受影响，仅重新编译这些受影响的模块，然后将更新后的模块代码发送到浏览器（websocket）。浏览器中的 HMR 运行时会接收这些更新，并用新模块替换旧模块，而无需刷新整个页面。
  - 未开启热更新
    - 若未开启热更新，webpack-dev-server 在检测到文件变化时，会重新打包整个项目并刷新浏览器页面。
    - 原理：由于没有 HMR 机制来单独更新模块，当文件变化时，webpack 会重新从入口文件开始解析所有模块，生成新的打包文件，然后通知浏览器重新加载页面以显示最新的打包结果。

### 传输性能优化
1. **分包**
  - 什么是分包？将一个整体的代码，分布到不同的打包文件中
  - 为什么要分包？
    - 减少公共代码(多入口引用了同一个库)，降低总体积，特别是一些大型的第三方库
    - 充分利用浏览器缓存
  - 什么时候要分包？
    - 多个 chunk 引入了公共模块
    - 公共模块体积较大或较少的变动
  - 手动分包
    - 手动打包的过程：
      1. 开启 output.library 暴露公共模块
      2. 用 DllPlugin 创建资源清单
      3. 用 DllReferencePlugin 使用资源请求
    - 优点：
      1. 极大提升自身模块的打包速度
      2. 极大的缩小了自身文件体积
      3. 有利于浏览器缓存第三方库的公共代码
    - 缺点：
      1. 配置繁琐
      2. 手动打包的库又有公共代码
  
  - 自动分包
    - 不同与手动分包，自动分包是从实际的角度出发，从一个更加宏观的角度来控制分包，而一般不对具体哪个包要分出去进行控制
    - webpack 在内部是使用 splitChunksPlugin 进行分包的
    - 基本配置
      1. chunks 配置项
        - 'async'（异步模块）。'async' 仅会对通过动态导入（懒加载）引入的异步模块进行代码分割。动态导入是指借助 ES6 的 import() 语法在运行时动态加载模块。
        - 'initial'（同步模块）。'initial' 只会对入口文件中通过静态导入引入的同步模块进行代码分割。静态导入是指使用 import ... from ... 语法在文件顶部引入模块。
        - 'all'（全部模块）。'all' 会对同步和异步模块都进行代码分割，也就是涵盖所有通过静态导入和动态导入引入的模块，前两个总和。
      2. maxSize
        - 该配置可以控制包的最大字节数，如果某个包(包括分出来的包)超过了该值，则 webpack 会尽可能的将其分离成多个包
        - 分包的基础单位是模块，如果一个完整的模块超过了该体积，它是无法做到再切割的，因此，尽管使用了这个配置，完全有可能某个包还是会超过这个体积
      3. minChunks：一个模块被多少个 chunk 使用时，才会进行分包，默认值为1
      4. minSize：当分包达到多少字节后才允许被真正的拆分，默认值30000 30kb
    - 缓存组 cacheGroups
      - 之前配置的分包策略是全局的，而实际上，分包策略是基于缓存组的
      - 每个缓存组提供一套独有的策略，webpack 按照缓存组的优先级依次处理每个缓存组，被缓存组处理过的分包不需要再次分包
      - 默认情况下，webpack 提供了两个缓存组：
      ```js
      module.exports = {
        optimozation: {
          splitChunks: {
            cacheGroups: {
              vendors: {
                test: /node_modules/,
                priority: -10 // 优先级
              },
              default: {
                minChunks: 2, // 当一个模块被 2 个 chunk 使用时，进行分包
                priority: -20,
                resueExisingChunk: true // 重用已经被分离出去的 chunk
              }
            }
          }
        }
      }
      ```
2. **单模块体积优化**
  - 代码压缩：减少代码体积，破坏代码的可读性，提升破解成本，一般在生产环境中使用

  - tree shaking 可以移除模块之间的无效代码
    - webpack 会从入口模块出发寻找依赖关系，当解析一个模块时，webpack 会根据 es6 的模块导入语句来判断，该模块依赖了另一个模块的哪个导出
    - webpack 之所以选择 es6 的模块导入语句，是因为 es6 模块 有以下特点：
      1. 导入导出语句只能顶层语句
      2. import 的模块名只能是字符串常量
      3. improt 绑定的变量是不可变的
      这些特征都非常有利于分析出稳定的依赖
    
  - 懒加载 improt()

  - gzip