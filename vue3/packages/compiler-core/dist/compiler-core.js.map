{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["// \u7F16\u8BD1\u4E3B\u8981\u5206\u4E3A\u4E09\u6B65\n// 1\u3001\u9700\u8981\u5C06\u6A21\u7248\u8F6C\u5316\u6210 ast \u8BED\u6CD5\u6811\n// 2\u3001\u8F6C\u5316\u751F\u6210 codegennode\n// 3\u3001\u8F6C\u5316\u6210 render \u51FD\u6570\n\nimport { NodeTypes } from \"./ast\"\n\nfunction createParserContext(content) {\n  return {\n    originalSource: content,\n    source: content,\n    line: 1,\n    column: 1,\n    offset: 0\n  }\n}\n\nfunction createRoot(children) {\n  return {\n    type: NodeTypes.ROOT,\n    children\n  }\n}\n\nfunction isEnd(content: string) {\n  return !content.length\n}\n\nfunction backwardMoveStr(context, index) {\n  let str = context.source\n  context.source = str.slice(index)\n}\n\nfunction parseText(context, content: string) { // \u5185\u5BB9   {{}}\n  const arr = ['{{', '<']\n\n  let data\n  for (const item of arr) {\n    const findIdx = content.indexOf(item)\n    // \u8BF4\u660E\u5B58\u5728\n    if (findIdx !== -1) {\n      data = content.slice(0, findIdx)\n      // \u5411\u540E\u79FB\u52A8\u5B57\u7B26\n      backwardMoveStr(context, findIdx)\n      break\n    } else {\n      data = content\n      // \u5411\u540E\u79FB\u52A8\u5B57\u7B26\n      backwardMoveStr(context, content.length - 1)\n    }\n  }\n\n  return {\n    type: NodeTypes.TEXT,\n    content: data\n  }\n}\n\nfunction parserChildren(context) {\n  const nodes = [] as any[]\n\n  // \u6CA1\u5B57\u7B26\u4E86\u9000\u51FA\n  while (!isEnd(context.source)) {\n    const content = context.source as string\n\n    let node\n    if (content.startsWith(\"{{\")) { // \u5B57\u7B26\u4E32\u9996\u662F\u5426\u5B58\u5728 {{ \u5F00\u5934\n      // \u8868\u8FBE\u5F0F\n    } else if (content[0] === '<') { // \u5B57\u7B26\u4E32\u9996\u662F\u5426\u662F < \u5F00\u5934\n      // \u5143\u7D20\n    } else { // \u5B57\u7B26\u4E32\u9996\u662F\u5426\u662F \u6587\u672C \u5F00\u5934\n      // \u6587\u672C\n      node = parseText(context, content)\n    }\n\n    nodes.push(node)\n  }\n\n  return nodes\n}\n\nexport function parse(template) {\n  const context = createParserContext(template)\n\n  return createRoot(parserChildren(context))\n}"],
  "mappings": ";AAOA,SAAS,oBAAoB,SAAS;AACpC,SAAO;AAAA,IACL,gBAAgB;AAAA,IAChB,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,QAAQ;AAAA,EACV;AACF;AAEA,SAAS,WAAW,UAAU;AAC5B,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AAEA,SAAS,MAAM,SAAiB;AAC9B,SAAO,CAAC,QAAQ;AAClB;AAEA,SAAS,gBAAgB,SAAS,OAAO;AACvC,MAAI,MAAM,QAAQ;AAClB,UAAQ,SAAS,IAAI,MAAM,KAAK;AAClC;AAEA,SAAS,UAAU,SAAS,SAAiB;AAC3C,QAAM,MAAM,CAAC,MAAM,GAAG;AAEtB,MAAI;AACJ,aAAW,QAAQ,KAAK;AACtB,UAAM,UAAU,QAAQ,QAAQ,IAAI;AAEpC,QAAI,YAAY,IAAI;AAClB,aAAO,QAAQ,MAAM,GAAG,OAAO;AAE/B,sBAAgB,SAAS,OAAO;AAChC;AAAA,IACF,OAAO;AACL,aAAO;AAEP,sBAAgB,SAAS,QAAQ,SAAS,CAAC;AAAA,IAC7C;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,IACA,SAAS;AAAA,EACX;AACF;AAEA,SAAS,eAAe,SAAS;AAC/B,QAAM,QAAQ,CAAC;AAGf,SAAO,CAAC,MAAM,QAAQ,MAAM,GAAG;AAC7B,UAAM,UAAU,QAAQ;AAExB,QAAI;AACJ,QAAI,QAAQ,WAAW,IAAI,GAAG;AAAA,IAE9B,WAAW,QAAQ,CAAC,MAAM,KAAK;AAAA,IAE/B,OAAO;AAEL,aAAO,UAAU,SAAS,OAAO;AAAA,IACnC;AAEA,UAAM,KAAK,IAAI;AAAA,EACjB;AAEA,SAAO;AACT;AAEO,SAAS,MAAM,UAAU;AAC9B,QAAM,UAAU,oBAAoB,QAAQ;AAE5C,SAAO,WAAW,eAAe,OAAO,CAAC;AAC3C;",
  "names": []
}
