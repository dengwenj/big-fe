## 请求库的封装  等会去看下**参数归一化**

### 背景
#### axios
* axios 虽然很成熟，但它只是一个基础库，没有提供诸多的上层功能，比如：
* 1、请求重试
* 2、请求缓存
* 3、请求幂等
* 4、请求串行
* 5、请求并发

#### VueRequest / SWR
* 它们虽然提供的功能很多，但仍然存在诸多问题：
* 1、与上层框架过渡绑定导致开发场景受限，也无法提供统一的 API
* 2、成熟度不够，issue 的回复也难以做到及时，存在一定风险
* 3、它们没有聚合基础请求库，仍然需要手动整合
* 公共库不包含公司内部制定的协议规范，即便使用公共库，也必须针对它们做二次封装，所以，需要自行封装一套适配公司业务的前端请求库

### 方案与实现
* 整个库结构包含三层，从下往上依次是：
* 1、请求实现层：提供请求基本功能
* 2、request-core：提供网络上层控制，比如请求串行、请求并行、请求重试、请求防重等功能
* 3、request-bus：为请求绑定业务功能，该层接入公司内部协议规范和接口文档，向外提供业务接口

#### 优化设计
* 在三层中，请求实现层的实现有多种方式：
* 1、基于 XHR 原生
* 2、基于 fetch 原生
* 3、基于 axios 等第三方库
* 这种实现的多样性可能导致这一层的不稳定，而 request-imp 是基础层，它的不稳定会传到上一层。所以必须寻求一种方案来隔离这种不稳定性。
* 我们可以基于 DIP(Dependence Inversion Principle, 依赖倒置原则)，彻底将 request-core 和请求的实现解耦，使用**接口**

#### 请求缓存
* 请求缓存是指创建一个带有缓存的请求，当没有命中缓存时发送请求并缓存结果，当有缓存时直接返回缓存
* 请求结果怎么存？存在哪？缓存键是什么？
* 统一接口，实现类实现这个关于缓存方案的接口
* storage 方案，indexdb方案，SW方案，WebSQL方案，Cookie方案，内存方案

#### 请求幂等（重复）
* 在网络请求中，很多接口都要求幂等性，比如支付，同一订单多次支付和一次支付对用户余额的影响应该是一样的。
* 要解决这一问题，就必须保证：**要求幂等的请求不能重复提交**
* 这里的关键问题就在于定义什么是重复？
* 我们可以把重复定义为：请求方法、请求头、请求体完全一致，因此，我们可以使用 hash 将它们编码成一个字符串，一样的就是重复，就走缓存

#### 样板代码(用标准化工具去自动化生成)
* 公司的 API 接口数量庞大并且时常变化，如果 request-bus 层全部人工处理不仅耗时，而且容易出错。
* 可以通过一些标准化的工具让整个过程自动化
* 补丁：有时候样板代码可能不能满足需求，需要手动进行改动，我们可以使用打补丁的方式去修改样板代码，做法非常简单